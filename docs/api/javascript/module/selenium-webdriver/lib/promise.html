<!DOCTYPE html><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="Content-Language" content="en"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>selenium-webdriver/lib/promise</title><link href="../../../dossier.css" rel="stylesheet" type="text/css"><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><div class="content"><main><article><section class="intro"><div class="codelink"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3016" target="_blank">View Source</a></div><h1 class="title"><div>module selenium-webdriver/lib/promise</div></h1><p>The promise module is centered around the <a href="promise_exports_ControlFlow.html">ControlFlow</a>, a class
that coordinates the execution of asynchronous tasks. The ControlFlow allows
users to focus on the imperative commands for their script without worrying
about chaining together every single asynchronous action, which can be
tedious and verbose. APIs may be layered on top of the control flow to read
as if they were synchronous. For instance, the core
<a href="webdriver_exports_WebDriver.html">WebDriver</a> API is built on top of the
control flow, allowing users to write</p>
<pre><code> driver.get(&#39;http://www.google.com/ncr&#39;);
 driver.findElement({name: &#39;q&#39;}).sendKeys(&#39;webdriver&#39;);
 driver.findElement({name: &#39;btnGn&#39;}).click();
</code></pre>
<p>instead of</p>
<pre><code> driver.get(&#39;http://www.google.com/ncr&#39;)
 .then(function() {
   return driver.findElement({name: &#39;q&#39;});
 })
 .then(function(q) {
   return q.sendKeys(&#39;webdriver&#39;);
 })
 .then(function() {
   return driver.findElement({name: &#39;btnG&#39;});
 })
 .then(function(btnG) {
   return btnG.click();
 });
</code></pre>
<h2>Tasks and Task Queues</h2>
<p>The control flow is based on the concept of tasks and task queues. Tasks are
functions that define the basic unit of work for the control flow to execute.
Each task is scheduled via <a href="promise_exports_ControlFlow.html#execute"><code>ControlFlow#execute()</code></a>, which will return
a <a href="promise_exports_Promise.html"><code>ManagedPromise</code></a> that will be resolved with the task&#39;s
result.</p>
<p>A task queue contains all of the tasks scheduled within a single turn of the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">JavaScript event loop</a>. The control flow will create a new task queue
the first time a task is scheduled within an event loop.</p>
<pre><code> var flow &#61; promise.controlFlow();
 flow.execute(foo);       // Creates a new task queue and inserts foo.
 flow.execute(bar);       // Inserts bar into the same queue as foo.
 setTimeout(function() {
   flow.execute(baz);     // Creates a new task queue and inserts baz.
 }, 0);
</code></pre>
<p>Whenever the control flow creates a new task queue, it will automatically
begin executing tasks in the next available turn of the event loop. This
execution is scheduled using a &#34;micro-task&#34; timer, such as a (native)
<code>ManagedPromise.then()</code> callback.</p>
<pre><code> setTimeout(() &#61;&gt; console.log(&#39;a&#39;));
 ManagedPromise.resolve().then(() &#61;&gt; console.log(&#39;b&#39;));  // A native promise.
 flow.execute(() &#61;&gt; console.log(&#39;c&#39;));
 ManagedPromise.resolve().then(() &#61;&gt; console.log(&#39;d&#39;));
 setTimeout(() &#61;&gt; console.log(&#39;fin&#39;));
 // b
 // c
 // d
 // a
 // fin
</code></pre>
<p>In the example above, b/c/d is logged before a/fin because native promises
and this module use &#34;micro-task&#34; timers, which have a higher priority than
&#34;macro-tasks&#34; like <code>setTimeout</code>.</p>
<h2>Task Execution</h2>
<p>Upon creating a task queue, and whenever an exisiting queue completes a task,
the control flow will schedule a micro-task timer to process any scheduled
tasks. This ensures no task is ever started within the same turn of the
JavaScript event loop in which it was scheduled, nor is a task ever started
within the same turn that another finishes.</p>
<p>When the execution timer fires, a single task will be dequeued and executed.
There are several important events that may occur while executing a task
function:</p>
<ol><li>A new task queue is created by a call to <a href="promise_exports_ControlFlow.html#execute"><code>ControlFlow#execute()</code></a>.
Any tasks scheduled within this task queue are considered subtasks of the
current task.</li><li>The task function throws an error. Any scheduled tasks are immediately
discarded and the task&#39;s promised result (previously returned by
<a href="promise_exports_ControlFlow.html#execute"><code>ControlFlow#execute()</code></a>) is immediately rejected with the thrown
error.</li><li>The task function returns sucessfully.</li></ol>
<p>If a task function created a new task queue, the control flow will wait for
that queue to complete before processing the task result. If the queue
completes without error, the flow will settle the task&#39;s promise with the
value originaly returned by the task function. On the other hand, if the task
queue termintes with an error, the task&#39;s promise will be rejected with that
error.</p>
<pre><code> flow.execute(function() {
   flow.execute(() &#61;&gt; console.log(&#39;a&#39;));
   flow.execute(() &#61;&gt; console.log(&#39;b&#39;));
 });
 flow.execute(() &#61;&gt; console.log(&#39;c&#39;));
 // a
 // b
 // c
</code></pre>
<h2>ManagedPromise Integration</h2>
<p>In addition to the <a href="promise_exports_ControlFlow.html"><code>ControlFlow</code></a> class, the promise module also exports
a <a href="https://promisesaplus.com/">ManagedPromise/A&#43;</a> <a href="promise_exports_Promise.html">implementation</a> that is deeply
integrated with the ControlFlow. First and foremost, each promise
<a href="promise_exports_Promise.html#then">callback</a> is scheduled with the
control flow as a task. As a result, each callback is invoked in its own turn
of the JavaScript event loop with its own task queue. If any tasks are
scheduled within a callback, the callback&#39;s promised result will not be
settled until the task queue has completed.</p>
<pre><code> promise.fulfilled().then(function() {
   flow.execute(function() {
     console.log(&#39;b&#39;);
   });
 }).then(() &#61;&gt; console.log(&#39;a&#39;));
 // b
 // a
</code></pre>
<h3>Scheduling ManagedPromise Callbacks <a id="scheduling_callbacks"></a></h3>
<p>How callbacks are scheduled in the control flow depends on when they are
attached to the promise. Callbacks attached to a <em>previously</em> resolved
promise are immediately enqueued as subtasks of the currently running task.</p>
<pre><code> var p &#61; promise.fulfilled();
 flow.execute(function() {
   flow.execute(() &#61;&gt; console.log(&#39;A&#39;));
   p.then(      () &#61;&gt; console.log(&#39;B&#39;));
   flow.execute(() &#61;&gt; console.log(&#39;C&#39;));
   p.then(      () &#61;&gt; console.log(&#39;D&#39;));
 }).then(function() {
   console.log(&#39;fin&#39;);
 });
 // A
 // B
 // C
 // D
 // fin
</code></pre>
<p>When a promise is resolved while a task function is on the call stack, any
callbacks also registered in that stack frame are scheduled as if the promise
were already resolved:</p>
<pre><code> var d &#61; promise.defer();
 flow.execute(function() {
   flow.execute(  () &#61;&gt; console.log(&#39;A&#39;));
   d.promise.then(() &#61;&gt; console.log(&#39;B&#39;));
   flow.execute(  () &#61;&gt; console.log(&#39;C&#39;));
   d.promise.then(() &#61;&gt; console.log(&#39;D&#39;));

   d.fulfill();
 }).then(function() {
   console.log(&#39;fin&#39;);
 });
 // A
 // B
 // C
 // D
 // fin
</code></pre>
<p>Callbacks attached to an <em>unresolved</em> promise within a task function are
only weakly scheduled as subtasks and will be dropped if they reach the
front of the queue before the promise is resolved. In the example below, the
callbacks for <code>B</code> &amp; <code>D</code> are dropped as sub-tasks since they are attached to
an unresolved promise when they reach the front of the task queue.</p>
<pre><code> var d &#61; promise.defer();
 flow.execute(function() {
   flow.execute(  () &#61;&gt; console.log(&#39;A&#39;));
   d.promise.then(() &#61;&gt; console.log(&#39;B&#39;));
   flow.execute(  () &#61;&gt; console.log(&#39;C&#39;));
   d.promise.then(() &#61;&gt; console.log(&#39;D&#39;));

   setTimeout(d.fulfill, 20);
 }).then(function() {
   console.log(&#39;fin&#39;)
 });
 // A
 // C
 // fin
 // B
 // D
</code></pre>
<p>If a promise is resolved while a task function is on the call stack, any
previously registered and unqueued callbacks (i.e. either attached while no
task was on the call stack, or previously dropped as described above) act as
<em>interrupts</em> and are inserted at the front of the task queue. If multiple
promises are fulfilled, their interrupts are enqueued in the order the
promises are resolved.</p>
<pre><code> var d1 &#61; promise.defer();
 d1.promise.then(() &#61;&gt; console.log(&#39;A&#39;));

 var d2 &#61; promise.defer();
 d2.promise.then(() &#61;&gt; console.log(&#39;B&#39;));

 flow.execute(function() {
   d1.promise.then(() &#61;&gt; console.log(&#39;C&#39;));
   flow.execute(() &#61;&gt; console.log(&#39;D&#39;));
 });
 flow.execute(function() {
   flow.execute(() &#61;&gt; console.log(&#39;E&#39;));
   flow.execute(() &#61;&gt; console.log(&#39;F&#39;));
   d1.fulfill();
   d2.fulfill();
 }).then(function() {
   console.log(&#39;fin&#39;);
 });
 // D
 // A
 // C
 // B
 // E
 // F
 // fin
</code></pre>
<p>Within a task function (or callback), each step of a promise chain acts as
an interrupt on the task queue:</p>
<pre><code> var d &#61; promise.defer();
 flow.execute(function() {
   d.promise.
       then(() &#61;&gt; console.log(&#39;A&#39;)).
       then(() &#61;&gt; console.log(&#39;B&#39;)).
       then(() &#61;&gt; console.log(&#39;C&#39;)).
       then(() &#61;&gt; console.log(&#39;D&#39;));

   flow.execute(() &#61;&gt; console.log(&#39;E&#39;));
   d.fulfill();
 }).then(function() {
   console.log(&#39;fin&#39;);
 });
 // A
 // B
 // C
 // D
 // E
 // fin
</code></pre>
<p>If there are multiple promise chains derived from a single promise, they are
processed in the order created:</p>
<pre><code> var d &#61; promise.defer();
 flow.execute(function() {
   var chain &#61; d.promise.then(() &#61;&gt; console.log(&#39;A&#39;));

   chain.then(() &#61;&gt; console.log(&#39;B&#39;)).
       then(() &#61;&gt; console.log(&#39;C&#39;));

   chain.then(() &#61;&gt; console.log(&#39;D&#39;)).
       then(() &#61;&gt; console.log(&#39;E&#39;));

   flow.execute(() &#61;&gt; console.log(&#39;F&#39;));

   d.fulfill();
 }).then(function() {
   console.log(&#39;fin&#39;);
 });
 // A
 // B
 // C
 // D
 // E
 // F
 // fin
</code></pre>
<p>Even though a subtask&#39;s promised result will never resolve while the task
function is on the stack, it will be treated as a promise resolved within the
task. In all other scenarios, a task&#39;s promise behaves just like a normal
promise. In the sample below, <code>C/D</code> is loggged before <code>B</code> because the
resolution of <code>subtask1</code> interrupts the flow of the enclosing task. Within
the final subtask, <code>E/F</code> is logged in order because <code>subtask1</code> is a resolved
promise when that task runs.</p>
<pre><code> flow.execute(function() {
   var subtask1 &#61; flow.execute(() &#61;&gt; console.log(&#39;A&#39;));
   var subtask2 &#61; flow.execute(() &#61;&gt; console.log(&#39;B&#39;));

   subtask1.then(() &#61;&gt; console.log(&#39;C&#39;));
   subtask1.then(() &#61;&gt; console.log(&#39;D&#39;));

   flow.execute(function() {
     flow.execute(() &#61;&gt; console.log(&#39;E&#39;));
     subtask1.then(() &#61;&gt; console.log(&#39;F&#39;));
   });
 }).then(function() {
   console.log(&#39;fin&#39;);
 });
 // A
 // C
 // D
 // B
 // E
 // F
 // fin
</code></pre>
<p>Finally, consider the following:</p>
<pre><code> var d &#61; promise.defer();
 d.promise.then(() &#61;&gt; console.log(&#39;A&#39;));
 d.promise.then(() &#61;&gt; console.log(&#39;B&#39;));

 flow.execute(function() {
   flow.execute(  () &#61;&gt; console.log(&#39;C&#39;));
   d.promise.then(() &#61;&gt; console.log(&#39;D&#39;));

   flow.execute(  () &#61;&gt; console.log(&#39;E&#39;));
   d.promise.then(() &#61;&gt; console.log(&#39;F&#39;));

   d.fulfill();

   flow.execute(  () &#61;&gt; console.log(&#39;G&#39;));
   d.promise.then(() &#61;&gt; console.log(&#39;H&#39;));
 }).then(function() {
   console.log(&#39;fin&#39;);
 });
 // A
 // B
 // C
 // D
 // E
 // F
 // G
 // H
 // fin
</code></pre>
<p>In this example, callbacks are registered on <code>d.promise</code> both before and
during the invocation of the task function. When <code>d.fulfill()</code> is called,
the callbacks registered before the task (<code>A</code> &amp; <code>B</code>) are registered as
interrupts. The remaining callbacks were all attached within the task and
are scheduled in the flow as standard tasks.</p>
<h2>Generator Support</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">Generators</a> may be scheduled as tasks within a control flow or attached
as callbacks to a promise. Each time the generator yields a promise, the
control flow will wait for that promise to settle before executing the next
iteration of the generator. The yielded promise&#39;s fulfilled value will be
passed back into the generator:</p>
<pre><code> flow.execute(function* () {
   var d &#61; promise.defer();

   setTimeout(() &#61;&gt; console.log(&#39;...waiting...&#39;), 25);
   setTimeout(() &#61;&gt; d.fulfill(123), 50);

   console.log(&#39;start: &#39; &#43; Date.now());

   var value &#61; yield d.promise;
   console.log(&#39;mid: %d; value &#61; %d&#39;, Date.now(), value);

   yield promise.delayed(10);
   console.log(&#39;end: &#39; &#43; Date.now());
 }).then(function() {
   console.log(&#39;fin&#39;);
 });
 // start: 0
 // ...waiting...
 // mid: 50; value &#61; 123
 // end: 60
 // fin
</code></pre>
<p>Yielding the result of a promise chain will wait for the entire chain to
complete:</p>
<pre><code> promise.fulfilled().then(function* () {
   console.log(&#39;start: &#39; &#43; Date.now());

   var value &#61; yield flow.
       execute(() &#61;&gt; console.log(&#39;A&#39;)).
       then(   () &#61;&gt; console.log(&#39;B&#39;)).
       then(   () &#61;&gt; 123);

   console.log(&#39;mid: %s; value &#61; %d&#39;, Date.now(), value);

   yield flow.execute(() &#61;&gt; console.log(&#39;C&#39;));
 }).then(function() {
   console.log(&#39;fin&#39;);
 });
 // start: 0
 // A
 // B
 // mid: 2; value &#61; 123
 // C
 // fin
</code></pre>
<p>Yielding a <em>rejected</em> promise will cause the rejected value to be thrown
within the generator function:</p>
<pre><code> flow.execute(function* () {
   console.log(&#39;start: &#39; &#43; Date.now());
   try {
     yield promise.delayed(10).then(function() {
       throw Error(&#39;boom&#39;);
     });
   } catch (ex) {
     console.log(&#39;caught time: &#39; &#43; Date.now());
     console.log(ex.message);
   }
 });
 // start: 0
 // caught time: 10
 // boom
</code></pre>
<h1>Error Handling</h1>
<p>ES6 promises do not require users to handle a promise rejections. This can
result in subtle bugs as the rejections are silently &#34;swallowed&#34; by the
ManagedPromise class.</p>
<pre><code> ManagedPromise.reject(Error(&#39;boom&#39;));
 // ... *crickets* ...
</code></pre>
<p>Selenium&#39;s promise module, on the other hand, requires that every rejection
be explicitly handled. When a <a href="promise_exports_Promise.html">ManagedPromise</a> is
rejected and no callbacks are defined on that promise, it is considered an
<em>unhandled rejection</em> and reproted to the active task queue. If the rejection
remains unhandled after a single turn of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">event loop</a> (scheduled
with a micro-task), it will propagate up the stack.</p>
<h2>Error Propagation</h2>
<p>If an unhandled rejection occurs within a task function, that task&#39;s promised
result is rejected and all remaining subtasks are discarded:</p>
<pre><code> flow.execute(function() {
   // No callbacks registered on promise -&gt; unhandled rejection
   promise.rejected(Error(&#39;boom&#39;));
   flow.execute(function() { console.log(&#39;this will never run&#39;); });
 }).catch(function(e) {
   console.log(e.message);
 });
 // boom
</code></pre>
<p>The promised results for discarded tasks are silently rejected with a
cancellation error and existing callback chains will never fire.</p>
<pre><code> flow.execute(function() {
   promise.rejected(Error(&#39;boom&#39;));
   flow.execute(function() { console.log(&#39;a&#39;); }).
       then(function() { console.log(&#39;b&#39;); });
 }).catch(function(e) {
   console.log(e.message);
 });
 // boom
</code></pre>
<p>An unhandled rejection takes precedence over a task function&#39;s returned
result, even if that value is another promise:</p>
<pre><code> flow.execute(function() {
   promise.rejected(Error(&#39;boom&#39;));
   return flow.execute(someOtherTask);
 }).catch(function(e) {
   console.log(e.message);
 });
 // boom
</code></pre>
<p>If there are multiple unhandled rejections within a task, they are packaged
in a <a href="promise_exports_MultipleUnhandledRejectionError.html"><code>MultipleUnhandledRejectionError</code></a>, which has an <code>errors</code> property
that is a <code>Set</code> of the recorded unhandled rejections:</p>
<pre><code> flow.execute(function() {
   promise.rejected(Error(&#39;boom1&#39;));
   promise.rejected(Error(&#39;boom2&#39;));
 }).catch(function(ex) {
   console.log(ex instanceof MultipleUnhandledRejectionError);
   for (var e of ex.errors) {
     console.log(e.message);
   }
 });
 // boom1
 // boom2
</code></pre>
<p>When a subtask is discarded due to an unreported rejection in its parent
frame, the existing callbacks on that task will never settle and the
callbacks will not be invoked. If a new callback is attached ot the subtask
<em>after</em> it has been discarded, it is handled the same as adding a callback
to a cancelled promise: the error-callback path is invoked. This behavior is
intended to handle cases where the user saves a reference to a task promise,
as illustrated below.</p>
<pre><code> var subTask;
 flow.execute(function() {
   promise.rejected(Error(&#39;boom&#39;));
   subTask &#61; flow.execute(function() {});
 }).catch(function(e) {
   console.log(e.message);
 }).then(function() {
   return subTask.then(
       () &#61;&gt; console.log(&#39;subtask success!&#39;),
       (e) &#61;&gt; console.log(&#39;subtask failed:\n&#39; &#43; e));
 });
 // boom
 // subtask failed:
 // DiscardedTaskError: Task was discarded due to a previous failure: boom
</code></pre>
<p>When a subtask fails, its promised result is treated the same as any other
promise: it must be handled within one turn of the rejection or the unhandled
rejection is propagated to the parent task. This means users can catch errors
from complex flows from the top level task:</p>
<pre><code> flow.execute(function() {
   flow.execute(function() {
     flow.execute(function() {
       throw Error(&#39;fail!&#39;);
     });
   });
 }).catch(function(e) {
   console.log(e.message);
 });
 // fail!
</code></pre>
<h2>Unhandled Rejection Events</h2>
<p>When an unhandled rejection propagates to the root of the control flow, the
flow will emit an <strong>uncaughtException</strong> event. If no listeners are registered
on the flow, the error will be rethrown to the global error handler: an
<strong>uncaughtException</strong> event from the
<a href="https://nodejs.org/api/process.html"><code>process</code></a> object in node, or
<code>window.onerror</code> when running in a browser.</p>
<p>Bottom line: you <strong><em>must</em></strong> handle rejected promises.</p>
<h1>ManagedPromise/A&#43; Compatibility</h1>
<p>This <code>promise</code> module is compliant with the <a href="https://promisesaplus.com/">ManagedPromise/A&#43;</a> specification
except for sections <code>2.2.6.1</code> and <code>2.2.6.2</code>:</p>
<blockquote>
<ul><li><code>then</code> may be called multiple times on the same promise.
<ul><li>If/when <code>promise</code> is fulfilled, all respective <code>onFulfilled</code> callbacks
must execute in the order of their originating calls to <code>then</code>.</li><li>If/when <code>promise</code> is rejected, all respective <code>onRejected</code> callbacks
must execute in the order of their originating calls to <code>then</code>.</li></ul>
</li></ul>
</blockquote>
<p>Specifically, the conformance tests contains the following scenario (for
brevity, only the fulfillment version is shown):</p>
<pre><code> var p1 &#61; ManagedPromise.resolve();
 p1.then(function() {
   console.log(&#39;A&#39;);
   p1.then(() &#61;&gt; console.log(&#39;B&#39;));
 });
 p1.then(() &#61;&gt; console.log(&#39;C&#39;));
 // A
 // C
 // B
</code></pre>
<p>Since the <a href="#scheduling_callbacks">ControlFlow</a> executes promise callbacks as
tasks, with this module, the result would be</p>
<pre><code> var p2 &#61; promise.fulfilled();
 p2.then(function() {
   console.log(&#39;A&#39;);
   p2.then(() &#61;&gt; console.log(&#39;B&#39;);
 });
 p2.then(() &#61;&gt; console.log(&#39;C&#39;));
 // A
 // B
 // C
</code></pre>
</section><section class="static-functions"><h2>Exported Functions</h2><section class="property" id="all"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3023" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>all(<wbr>arg0)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>&lt;(T|<a href="promise_exports_Promise.html">Promise</a>)&gt;</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_Promise.html">Promise</a></code></dl></dd></dl></section><section class="property" id="asap"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3024" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>asap(<wbr>arg0,<wbr> arg1,<wbr> arg2)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>*</code><dt class="named">arg1<code>Function</code><dt class="named">arg2<code>?Function=</code></dl></dd></dl></section><section class="property" id="captureStackTrace"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3025" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>captureStackTrace(<wbr>arg0,<wbr> arg1,<wbr> arg2)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">string</a></code><dt class="named">arg1<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">string</a></code><dt class="named">arg2<code>?Function=</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">Error</a></code></dl></dd></dl></section><section class="property" id="checkedNodeCall"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3026" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>checkedNodeCall(<wbr>arg0,<wbr> arg1)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>Function</code><dt class="named">arg1<code>...?</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_Promise.html">Promise</a></code></dl></dd></dl></section><section class="property" id="consume"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3027" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>consume(<wbr>arg0,<wbr> arg1,<wbr> arg2)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>Function</code><dt class="named">arg1<code>?<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">Object</a>=</code><dt class="named">arg2<code>...*</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_Promise.html">Promise</a></code></dl></dd></dl></section><section class="property" id="controlFlow"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3028" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>controlFlow()</div></h3><dl><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_ControlFlow.html">ControlFlow</a></code></dl></dd></dl></section><section class="property" id="createFlow"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3029" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>createFlow(<wbr>arg0)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>function(<a href="promise_exports_ControlFlow.html">ControlFlow</a>): ?</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_Promise.html">Promise</a></code></dl></dd></dl></section><section class="property" id="defer"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3030" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>defer()</div></h3><dl><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_Deferred.html">Deferred</a></code></dl></dd></dl></section><section class="property" id="delayed"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3031" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>delayed(<wbr>arg0)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">number</a></code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_Promise.html">Promise</a></code></dl></dd></dl></section><section class="property" id="filter"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3032" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>filter(<wbr>arg0,<wbr> arg1,<wbr> arg2)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>&lt;TYPE&gt;|<a href="promise_exports_Promise.html">Promise</a>)</code><dt class="named">arg1<code>function(TYPE, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">number</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>&lt;TYPE&gt;): ?(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean">boolean</a>|<a href="promise_exports_Promise.html">Promise</a>)</code><dt class="named">arg2<code>SELF=</code></dl></dd></dl></section><section class="property" id="fulfilled"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3033" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>fulfilled(<wbr>arg0)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>T=</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_Promise.html">Promise</a></code></dl></dd></dl></section><section class="property" id="fullyResolved"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3034" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>fullyResolved(<wbr>arg0)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>*</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_Promise.html">Promise</a></code></dl></dd></dl></section><section class="property" id="isGenerator"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3035" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>isGenerator(<wbr>arg0)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>Function</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean">boolean</a></code></dl></dd></dl></section><section class="property" id="isPromise"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3036" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>isPromise(<wbr>arg0)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>?</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean">boolean</a></code></dl></dd></dl></section><section class="property" id="map"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3037" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>map(<wbr>arg0,<wbr> arg1,<wbr> arg2)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>&lt;TYPE&gt;|<a href="promise_exports_Promise.html">Promise</a>)</code><dt class="named">arg1<code>function(TYPE, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">number</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>&lt;TYPE&gt;): ?</code><dt class="named">arg2<code>SELF=</code></dl></dd></dl></section><section class="property" id="rejected"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3038" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>rejected(<wbr>arg0)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>*=</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_Promise.html">Promise</a></code></dl></dd></dl></section><section class="property" id="setDefaultFlow"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3039" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>setDefaultFlow(<wbr>arg0)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code><a href="promise_exports_ControlFlow.html">ControlFlow</a></code></dl></dd></dl></section><section class="property" id="when"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3040" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>when(<wbr>arg0,<wbr> arg1,<wbr> arg2)</div></h3><dl><dt class="spec">Parameters</dt><dd><dl><dt class="named">arg0<code>*</code><dt class="named">arg1<code>?Function=</code><dt class="named">arg2<code>?Function=</code></dl></dd><dt class="spec">Returns</dt><dd><dl><dt><code><a href="promise_exports_Promise.html">Promise</a></code></dl></dd></dl></section></section><section class="static-properties"><h2>Exported Properties</h2><section class="property" id="LONG_STACK_TRACES"><div class="code-link"><a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3043" target="_blank" title="View source"><i class="material-icons">code</i></a></div><h3 class="name"><div>LONG_STACK_TRACES</div></h3><dl><dt class="spec">Type<dd>?</dd></dl></section></section><section class="types"><h2>Exported Types</h2><section class="property"><dl><dt><a href="promise_exports_CancellationError.html">CancellationError</a><dd><p>Error used when the computation of a promise is cancelled.</p>
<dt><a href="promise_exports_ControlFlow.html">ControlFlow</a><dd><p>Handles the execution of scheduled tasks, each of which may be an
asynchronous operation.</p>
<dt><a href="promise_exports_Deferred.html">Deferred</a><dd><p>Represents a value that will be resolved at some point in the future.</p>
<dt><a href="promise_exports_MultipleUnhandledRejectionError.html">MultipleUnhandledRejectionError</a><dd><p>Error used when there are multiple unhandled promise rejections detected
within a task or callback.</p>
<dt><a href="promise_exports_Promise.html">Promise</a><dd><p>Represents the eventual value of a completed operation.</p>
<dt><a href="promise_exports_Thenable.html">Thenable</a><dd><p>Thenable is a promise-like object with a <code>then</code> method which may be
used to schedule callbacks on a promised value.</p>
</dl></section></section></article></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><nav class="dossier-nav"><section><a class="title" href="../../../index.html" tabindex="2">Overview</a></section><section class="modules"><div class="toggle"><div class="title"><span class="item" tabindex="2">Modules</span><i class="material-icons">expand_more</i></div></div></section><section><a class="title" href="../../../Changes.html" tabindex="2">Changes</a></section></nav><script src="../../../types.js"></script><script src="../../../dossier.js"></script>